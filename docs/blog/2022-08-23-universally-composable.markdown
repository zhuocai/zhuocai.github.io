---
layout: post
---

<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>


This is my note from learning the paper [Universally Composable Security: A New Paradigm for Cryptographic Protocols](https://eprint.iacr.org/2000/067.pdf). Since my current interest in mainly in blockchain protocols, I will mostly discuss what I think is useful for a beginner-level blockchain protocol designer. 

## 1. Introduction

In short, UC is a framework to analyze the security of cryptographic protocols. The security refers to implementing the desired functionality of the protocol. This framework has been used widely in blockchain security analysis, where we expect a rigorous proof that the protocol really implements the blockchain ledger, under complicated real-world setting. 

Security analysis for blockchains is much more complicated than traditional computing systems because: 

* blockchain is a decentralized system, 
* a blockchain has many modules that might interact with each other, 
* blockchain allows dynamic participation, including adversarial attackers, 
* synchronous and secure communication channels might be unavailable. 

The core idea of UC framework is to decompose a complicated protocol to smaller protocols. These small protocols involve fewer parties, span shorter time intervals and realize simpler functionalities, so that their security analysis is much easier. If every sub-protocol can realize its own desired functionality, then the original protocol can also realize its functionality. This is guaranteed by universal composition theorem. 

The UC framework is a general framework for security analysis. Detailed examples include its application to Bitcoin [Bitcoin as a Transaction Ledger: A Composable Treatment](https://eprint.iacr.org/2017/149.pdf), security analysis of Ouroboros protocols. 

### 1.1 Bitcoin as a Transaction Ledger

This paper presents a ledger functionality for bitcoin that has the following properties: 
* Common prefix: For a single honest node, it might see forks at some time. The chain-selection rule, longest-chain-rule in Bitcoin for example, guarantees that the valid branches can grow limited blocks after the common prefix. For a single honest node, it might see two different valid chains at two different times. Then the two chains must share a long common prefix such that the shorter chain cannot grow \\( \ge k \\) blocks after the common prefix. 
* Chain growth: There must be a new block within a long enough time interval, even if the adversary wants to keep the chain from growing. 
* Chain quality: There must be a block generated by honest parties within any long consecutive sequence of blocks in a valid chain. 


The ledger functionality involves the additional functionality of: 
* clock: to run the blockchain in rounds, 
* random oracle: to choose the next block, 
* and diffusion network: to model the multi-cast communication network. 

Bitcoin implements the above ledger functionality. However, the ledger functionality is not limited to Bitcoin, but also applicable and illuminating for other blockchain models. 

### 1.2 Quick Overview

Functionality is a important element of UC framework. It is an abstraction of the intended function of a protocol. When a complicated protocol consists of sub-protocols, the sub-protocols can be called as modules. If we want to prove that the top-level protocol implements its desired function, or in other words, implements its ideal functionality, the UC treatment starts by replacing the subsidiary protocols with their respective ideal functionality. Then we show that each ideal functionality of the sub-protocols can be implemented by real-world protocols. To successfully make universal composition theorem, the UC framework has certain requirements for the sub-protocol substitution. 

In UC framework, the sub-protocol substitution is formally presented as emulation. Before presenting the formal definition of emulation, UC framework firstly defines machines, protocols, environment and adversaries. 

#### 1.2.1 Machine

The machine here is not necessarily an individual party as in other cryptographic protocols. It is defined as a computer program, which has its own fixed **identity**. If can represent both the actual computational process, and the abstract functionality. A machine can use other machines as subroutine machines. 

Machines are the only basic units of a protocol. In other definitions of systems, even if a machine is associated with its code, it requires an external communication channel to interact with other machines. In UC framework, this communication channel, although not a computer program, is also modeled as a machine. 

A machine, as an abstract computation model, has three communication tapes for interacting with internal world: **input**, **subroutine-output**, **backdoor**. If a machine \\( A \\) uses machine \\( B \\) as one of its subroutine machines, \\( A \\) can write on \\( B \\)'s input tape and \\( B \\) can write on \\( A \\)'s subroutine-output tape. Backdoor is designed for adversaries. If machine \\( A \\) can write to \\( B \\)'s backdoor tape, then \\( B \\) can also write on \\( A \\)'s backdoor tape. 

#### 1.2.2 Protocol

The UC framework designs protocol to model "multi-party protocols" run by collections of programs for a joint goal. In the definition here, a protocol \\( \pi \\) is simply a set of machines, which satisfies necessary consistency requirements for interaction: 
* If \\( \pi \\) contains a machine \\( \mu \\) of identity \\( ID \\) that is a caller of identity \\( ID^\prime \\), then \\( \pi \\) also contains the subroutine machine \\( \mu^\prime \\) of identity \\( ID^\prime \\). 
* In the other direction, if \\( \pi \\) contains a machine \\( \mu \\) that is a subroutine of \\( ID^\prime \\), then there are two cases. If \\( \pi \\) contains a machine \\( \mu^\prime \\) of identity \\( ID^\prime \\), then  
it is the caller of \\( \mu \\). Otherwise, the caller is external to the protocol. Say that \\( \mu \\) is a **main machine** of protocol \\( \pi \\) and \\( ID^\prime \\) is an **external identity** with respect to \\( \pi \\). Machines in \\( \pi \\) that are not main machines are called **internal machines**. 

To define security for protocols, the UC framework defines protocol execution and protocol emulation in the next step. 

#### 1.2.3 Protocol execution
The participants of an execution of a protocol \\( \pi \\) include the machines of \\( \pi \\) and two extra machines, modeling the *environment* \\( \mathcal{E} \\) and the *adversary* \\( \mathcal{A} \\). To start the execution, give input \\( z \\) to the environment machine. Then machines take turns to act. If one machine \\( \mu \\) of identity \\( ID \\) performs an instruction to send information to some identity \\( ID^\prime \\), the sender \\( \mu \\)'s execution is suspended. 

Depending on the sender and receiver, the execution can be different: 
* If the sender \\( \mu \\) is the environment machine \\( \mathcal{E} \\), then the message is sent to input tape of a machine \\( \mu^\prime \\) whose identity is \\( ID^\prime \\). In case that the current protocol \\( \pi \\) can be used as a subroutine by some upper level protocol, the caller machines in upper level are modeled within the environment. Therefore, for compatibility, the environment has the permission to choose arbitrary identity as the sender identity, as long as it is one of the recognized external identities of \\( \mu \\). This models how external machines interact with machines of protocol \\( \pi \\). If the receiver \\( ID\prime \\) is the adversary machine \\(\mathcal{A}\\), then no source identity is added. Then execution passes to the receiver \\(\mu^\prime\\). 
* Else if the sender is an existing machine in \\(\pi\\) or the adversary \\(\mathcal{A}\\) and the receiver also exists in the system, the message is added to the state of machine \\(\mu^\prime\\) of identity \\(ID^\prime\\). The sender identity is revealed to the receiver. 
* Else the receiver \\(ID^\prime\\) is an external identity of \\(\pi\\), the message is not directly sent to the receiver, but sent to the environment \\(\mathcal{E}\\). Then the environment handles execution. In this case, the message is a subroutine-output message from a main machine of \\(\pi\\) whose caller is an external machine. 
* If the sender \\(\mu\\) pauses without sending information then the environment machine resumes execution. 

The execution ends when \\(\mathcal{E}\\) halts. 

The output of the execution is defined as the output bit of \\(\mathcal{E}\\). Let \\( EXEC_{\pi, \mathcal{A}, \mathcal{E}}(z) \\) denote the random variable describing the output of an execution. The randomness is from the local random choices of all the involved machines during the single execution. Let \\( EXEC_{ \pi, \mathcal{A}, \mathcal{E} } \\) denote the ensemble \\( \\{ EXEC_{ \pi, \mathcal{A}, \mathcal{E} } (z) \\}_{z\in \\{0,1\\}^* } \\). 

#### 1.2.4 Protocol Emulation

For an functionality, assume there is an ideal protocol that realizes it. Further, if there is a real-world protocol that is similar to the ideal protocol, then this protocol also realizes the functionality. The relationship of similarity between protocols are defined via emulation. The core idea is that no environment can distinguish between interacting with the two protocols. Since there is an extra participant, the adversary \\(\mathcal{A}\\), a protocol \\(\pi\\) emulates another protocol \\(\phi\\) if no environment can distinguish between interacting with \\(\pi \\) plus an adversary of choice, and interacting with \\(\phi \\) plus some other adversary. The environment tries to guess between the two cases and then set its output bit. 

If the protocol \\(\pi\\) emulates the protocol \\(\phi\\), then \\(\pi\\) is at least as secure as \\(\phi\\). If an adversary can attack \\(\pi\\), then there is some adversary that can attack \\(\phi\\) similarly that no environment can tell the difference between the two cases. 

Formally define realizing an ideal functionality as emulating its ideal protocol. 

#### 1.2.5 Other

Inter-process communication can be modeled by communication machines. Party corruption can be modeled as the adversary sending "corrupt" requests to the environment/protocol and controls the corrupted party via the environment/protocol. The above simple model allows specifying many security assumptions. 

Although the above execution model is single-threaded, it can actually capture all the situations of distributed systems. 

## 2 Detailed model and UC theorem

Todo. 


## Reference
<ol>
  <li> Universally Composable Security: A New Paradigm for Cryptographic Protocols.  </li>
  <li> Bitcoin as a Transaction Ledger: A Composable Treatment. </li>
</ol>